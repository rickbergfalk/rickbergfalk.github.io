<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Rick Bergfalk's Directory of Things</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <a href="/"><h1>Rick Bergfalk</h1></a>
          <h2>Directory of Things</h2>
        </header>

        <hr>
	<a href="/posts/">Back to Posts</a>
	<hr>	
	<section id="main_content">
		<h1>
			NVARCHAR(MAX) is not for everything
		</h1>
		<small>
			April 2013
		</small>
		<hr>
		<div>
			<p>Thinking of using NVARCHAR(MAX) for every character string field in your database, or already doing it? </p>
<p>We&#39;re going to cover why you don&#39;t want to do that, and show you some real performance impacts of this anti-pattern.</p>
<h2>First Some Background</h2>
<p>Microsoft&#39;s SQL Server has an interesting data length for VARCHAR and NVARCHAR data types, called MAX. You can think of it as &quot;maximum amount of memory&quot; or &quot;unlimited.&quot; Now obviously it <em>can&#39;t really be unlimited</em>, but in the practical sense that&#39;s what its there for - big strings of text.</p>
<p>[N]VARCHAR(MAX) is the preferred replacement of [N]Text. Microsoft says so themselves (link to the article). They also mention something about how the data is stored differently depending on its size, and other details.</p>
<p>The reason this post exists is because I&#39;ve witnessed several times the practice of using MAX for every [N]VARCHAR data type in the database. Anywhere from names, descriptions, to small blocks of text usually less than 2000 characters... I&#39;ve seen MAX used for it.</p>
<p>Using MAX indiscriminately will impact your performance more than one would realize, and we&#39;re going to dive into why that is.</p>
<h2>Prepping our test data</h2>
<p>To showcase some of the pain-points MAX-for-everything introduces, let&#39;s build a phone book table. Our phone book is going to be for a big metropolitan area, covering several cities. Phone number will be the primary key. We&#39;ll add other indexes after the data is loaded.</p>
<pre><code>CREATE TABLE phonebook_max (
    PhoneNumber INT NOT NULL,
    CityId INT NOT NULL,
    LastName NVARCHAR(MAX) NOT NULL,
    FirstName NVARCHAR(MAX) NOT NULL,
    Address1 NVARCHAR(MAX) NOT NULL,
    Address2 NVARCHAR(MAX) NULL,
    CONSTRAINT [PK_phonebook_max] PRIMARY KEY CLUSTERED ([PhoneNumber])
)</code></pre>
<p>And because we want to compare how a MAX-for-everything table does against a sensibly-sized columns, we&#39;re going to create a second phone book as well, using more sane data size limits.</p>
<pre><code>CREATE TABLE phonebook (
    PhoneNumber INT NOT NULL,
    CityId INT NOT NULL,
    LastName NVARCHAR(50) NOT NULL,
    FirstName NVARCHAR(50) NOT NULL,
    Address1 NVARCHAR(200) NOT NULL,
    Address2 NVARCHAR(200) NULL,
    CONSTRAINT [PK_phonebook] PRIMARY KEY CLUSTERED ([PhoneNumber])
);</code></pre>
<p>Now that we have our tables in place, we&#39;ll fill them with some fake data. </p>
<p>Our tables will create 40,000 &quot;phone numbers&quot; in 9 &quot;cities.&quot; I&#39;m not bothering with a fancy data generator here, so our names are numbers, and the phone numbers aren&#39;t actual numbers, but it still works for what we want it to do.</p>
<pre><code>
SET NOCOUNT ON;
DECLARE @CityId INT;
DECLARE @PhoneNumberPart INT;

-- Populate the phonebook_max with some data
SET @CityId = 1;
WHILE (@CityId &lt; 10)
BEGIN 
    SET @PhoneNumberPart = 10001;
    WHILE (@PhoneNumberPart &lt; 50000)
    BEGIN 
        INSERT INTO phonebook_max (PhoneNumber, CityId, LastName, FirstName, Address1)
            VALUES (
                CAST(CAST(@CityId AS CHAR(1)) + CAST(@PhoneNumberPart AS CHAR(5)) AS INT),
                @CityId,
                CAST(@PhoneNumberPart AS CHAR(5)) + &#39; LastName&#39;,
                CAST(@PhoneNumberPart AS CHAR(5)) + &#39; FirstName&#39;,
                CAST(@PhoneNumberPart AS CHAR(5)) + &#39; Address1&#39;)
        SET @PhoneNumberPart = @PhoneNumberPart + 1;
    END
    SET @CityId = @CityId + 1;  
END 

-- Do it again, but for regular phonebook
SET @CityId = 1;
WHILE (@CityId &lt; 10)
BEGIN 
    SET @PhoneNumberPart = 10001;
    WHILE (@PhoneNumberPart &lt; 50000)
    BEGIN 
        INSERT INTO phonebook (PhoneNumber, CityId, LastName, FirstName, Address1)
            VALUES (
                CAST(CAST(@CityId AS CHAR(1)) + CAST(@PhoneNumberPart AS CHAR(5)) AS INT),
                @CityId,
                CAST(@PhoneNumberPart AS CHAR(5)) + &#39; LastName&#39;,
                CAST(@PhoneNumberPart AS CHAR(5)) + &#39; FirstName&#39;,
                CAST(@PhoneNumberPart AS CHAR(5)) + &#39; Address1&#39;)
        SET @PhoneNumberPart = @PhoneNumberPart + 1;
    END
    SET @CityId = @CityId + 1;  
END</code></pre>
<h2>Memory estimations get really big</h2>
<p>Something to be aware of when using MAX for everything is inflated estimated data sizes for records. Since SQL Server&#39;s MAX length could store something really big, SQL Server figures it should plan for that to maybe happen. </p>
<p>Let&#39;s run the following queries with Include Actual Estimation Plan turned on. </p>
<pre><code>SELECT TOP 1 * FROM phonebook;

SELECT TOP 1 * FROM phonebook_max;</code></pre>
<p>Hover over the line from the clustered index scan of PK_Phonebook and you&#39;ll see an estimated row size of 525 B. That number comes from the data lengths specified from our table. 200 + 200 + 50 + 50 + 4 + 4 + additional overhead = 525.</p>
<p><img src="http://rickbergfalk.com/images/2013-04-25-nvarchar-max-top-1-non-max.png" alt="Top 1 non max"></p>
<p>Alternatively, hover over the line from the clustered index scan of PK_Phonebook_max and you&#39;ll see an estimation of 16 KB!</p>
<p><img src="http://rickbergfalk.com/images/2013-04-25-nvarchar-max-top-1-max.png" alt="Top 1 non max"></p>
<p>Since the MAX data length was meant to store large amounts of data, SQL Server goes big on the estimate to ensure it has enough memory available to comfortably handle it all. Little does it know that it could actually get away with a fraction of that.</p>
<p>You might be thinking, &quot;Big deal, 16 KB is small&quot;, but as we&#39;re about to find out it starts to add up quick.</p>
<h2>MAX can&#39;t be indexed</h2>
<p>Another one of the main issues with using MAX for everything is the inability to index MAX columns. They can be added as an index INCLUDE column, but that won&#39;t help any searches or joins on that particular column. </p>
<p>A common use for a phone book would be to look people up by last name within a certain city. For our non-MAX table, the following index would be a nice fit, since it allows range queries by city, but also allows for a quick lookup for city and last name pair.</p>
<pre><code>CREATE NONCLUSTERED INDEX IX_phonebook_CityId_LastName 
    ON phonebook (CityId, LastName);</code></pre>
<p>We can&#39;t create that same index on the MAX table - the closest we could come is to add an index on CityId:</p>
<pre><code>CREATE NONCLUSTERED INDEX IX_phonebook_max_CityId 
    ON phonebook_max (CityId);</code></pre>
<p>If you look back at our data creation script, last name is the combination of the @PhoneNumberPart and &quot; LastName&quot;. With the execution plan on, let&#39;s get a record from the middle of our table from city 5:</p>
<pre><code>SELECT * 
FROM dbo.phonebook 
WHERE CityId = 5 AND LastName = N&#39;10123 LastName&#39;</code></pre>
<p>Exploring the execution plan, we see a nice efficient plan: and index seek with a key lookup, resulting in 1 record back with a small size.</p>
<p><img src="http://rickbergfalk.com/images/2013-04-25-nvarchar-max-by-city-lastname-non-max.png" alt="Select 1 by city and last name non max"></p>
<p>The story is a bit different though for our MAX table...</p>
<pre><code>SELECT * 
FROM dbo.phonebook_max
WHERE CityId = 5 AND LastName = N&#39;10123 LastName&#39;</code></pre>
<p>Oddly enough, SQL Server decides to completely ignore the index we put on CityId, and proceeds to scan the entire table instead. </p>
<p>TODO: Look into why SQL Server completely ignores the index. It might be because of the estimated row size. Make the same index on the non-max table as well, see how it behaves there. </p>
<h2>Index scan + big memory estimates = even bigger memory estimates</h2>

		</div>
	</section>
	<hr>
	<a href="/posts/">Back to Posts</a>

		<footer>
			
			<!--
			<section id="downloads" class="clearfix">
				<a href="https://github.com/rickbergfalk" id="view-on-github" class="button"><span>me on GitHub</span></a>
			</section>
			-->
			<p>
				Rick Bergfalk is a Business Intelligence developer that dabbles with web development on the side via Node.js.
			</p>
			<p class="footer-links">
				Â© Rick Bergfalk 2013 <a href="http://github.com/rickbergfalk">github</a> <a href="http://twitter.com/rickbergfalk">twitter</a>
			</p>
		</footer>

        
      </div>
    </div>
  </body>
</html>
